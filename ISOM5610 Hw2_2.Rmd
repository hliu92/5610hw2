---
title: "ISOM5610 HW2"
author: "Team 1"
date: "22 November 2018"
output: pdf_document
---

```{r}
setwd("~/MSBA/ISOM5610/HW2")
library(readxl)
bluestem <- as.data.frame(read_excel("bluestem.xls", sheet=1))
bluestem[,2:9] <- lapply(bluestem[,2:9], factor)
colnames(bluestem)[1] <- "Sales"
colnames(bluestem)[10] <- "Index"
str(bluestem)
```

```{r}
library(car)
# This function is a combination of Diagnostic plots, BP test, multicollinearity check for independent variables, and Cochrane-Orcutt test
check_assumption <- function(testfit){
    #Diagnostic plots
    stdres=rstandard(testfit)
    par(mfrow=c(2,2))
    qqnorm(stdres,main='Normal Probability Plot',xlab='Normal Quantiles',ylab='Standardized Residual Quantiles')
    abline(0,1)
    plot(testfit$fitted.values,stdres,main='Versus Fits',xlab='Fitted Value',ylab='Standardized Residual')
    abline(0,0,lty=3)
    hist(stdres,main='Histogram',xlab='Standardized Residual')
    plot(tail(timeindex,length(stdres)),stdres,type="o",main='Versus Order',xlab='TimeIndex',ylab='Standardized Residual')
    abline(0,0,lty=3)
    #BP test
    cat("====BP test====\n")
    print(ncvTest(testfit))
    #Checking multicollinearity for independent variables
    cat("\n====Checking multicollinearity for independent variables====\nVIF:\n")
    print(vif(testfit))
    #Cochrane-Orcutt test
    cat("\n====Cochrane-Orcutt test====")
    summary(lm(testfit$residuals~Lag(testfit$residuals, 1)))
}
```

# Data Exploration

```{r}
#Adding the time index predictor
bluestem$Weekday <- factor(names(bluestem[3:9])[max.col(bluestem[3:9])], 
                           levels = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"))
stan <- rep(c('Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'),50)
st <- 1
timeindex <- c()
for (lp in 1:249){
  timeindex[lp] <- st
  while (stan[st] != bluestem$Weekday[lp]){
    st <- st+1
    timeindex[lp] <- st
  }
}
bluestem$timeindex <- timeindex 
bluestem$n <- c(1:nrow(bluestem))
#See if there is linear trend along the time line
# Model 0.1 - Sales vs. full time line
fit0.1 <- lm(Sales ~ timeindex,data=bluestem)
summary(fit0.1)
plot(bluestem$timeindex,bluestem$Sales, type="l")
abline(fit0.1,col=2)
# Model 0.2 - Sales vs. open days time line 
fit0.2 <- lm(Sales ~ n, data=bluestem)
summary(fit0.2)
```

```{r}
## Add lag predictor for promotion (considering full time line)
prolag1 <- rep(0,249)
prolag1[c(1,108,120)] <- c(NA,1,1)
prolag2 <- rep(0,249)
prolag2[c(1,54,97,109)] <- c(NA,1,1,1)
bluestem$prolag1 <- prolag1
bluestem$prolag2 <- prolag2
## Add lag predictor for promotion (considering open days time line)
library(Hmisc)
bluestem$prolag1_0 <- Lag(bluestem$Promotion,1)
bluestem$prolag2_0 <- Lag(bluestem$Promotion,2)

## standardize index
index_table <- unique(bluestem[names(bluestem) %in% c("Weekday", "Index")])
bluestem$Index <- bluestem$Index*7/sum(index_table[,1])
## Deseaonalize Sales
bluestem$desSales <- bluestem$Sales/bluestem$Index
# Model 0.3 - De-seasonalized Sales (standard) vs. full time line
fit0.3 <- lm(desSales ~ timeindex,data=bluestem)
summary(fit0.3)
plot(bluestem$timeindex,bluestem$desSales, type="l")
abline(fit0.3,col=2)
# Model 0.4 - De-seasonalized Sales (standard) vs. open days time line 
fit0.4 <- lm(desSales ~ n, data=bluestem)
summary(fit0.4)
```


```{r}
index_table <- unique(bluestem[names(bluestem) %in% c("Weekday", "Index")])
library(ggplot2)
library(RColorBrewer)
ggplot(index_table, aes(x = Weekday, y = Index, fill=Weekday)) + 
    geom_bar(stat = "identity") + 
    geom_text(aes(label = sprintf("%0.2f", round(Index, digits = 2))), vjust=-0.6) + 
    scale_fill_manual(values=brewer.pal(7, "Blues")[1:7]) +
    labs(y="Nightly Index (Standardized)")
#Sales on different Weekdays
ggplot(bluestem, aes(x = Weekday, y = Sales, fill=Weekday)) + 
    geom_boxplot() + 
    geom_point(data=subset(bluestem, Promotion==1), mapping=aes(color=Promotion), size=3) + 
    scale_fill_manual(values=brewer.pal(7, "Blues")[1:7]) + 
    scale_color_manual(labels = "With Promotion", values="red")
#Sales with or without promotions
ggplot(bluestem, aes(x = Promotion, y = Sales, fill= Promotion)) +
    geom_boxplot()+
    scale_fill_manual(values=c(brewer.pal(7, "Blues")[4],brewer.pal(7, "Reds")[4]))
#De-seasonalized Sales with or without promotions
ggplot(bluestem, aes(x = Promotion, y = desSales, fill= Promotion)) + 
    geom_boxplot() + 
    scale_fill_manual(values=c(brewer.pal(7, "Blues")[4],brewer.pal(7, "Reds")[4])) +
    labs(y="Sales/Nightly Index")
```

## Additive Model
A regression model using dummy variables to account for the fixed Weekday??s effect.

```{r}
#Model add.fit.1 - Sales ~ time (full) + promo + dummy
bluestem_1 <- bluestem[,c(1:8,12)]
add.fit.1 <- lm(Sales ~ ., data = bluestem_1)
summary(add.fit.1)
```

**After the time index is added, Answer = 604.824**

```{r}
# Checking model assumptions
check_assumption(add.fit.1)
```
BP Test and CO Test don't pass!!!

########################
Try factor in lag effect
#########################
```{r}
#Model add.fit.2 - Sales ~ time (full) + promo (+lag1) + dummy
bluestem_1 <- bluestem[,c(1:8,12,14)]
add.fit.2 <- lm(Sales ~ ., data = bluestem_1)
summary(add.fit.2)
#Model add.fit.3 - Sales ~ time (full) + promo (+lag1&2) + dummy
bluestem_1 <- bluestem[,c(1:8,12,14,15)]
add.fit.3 <- lm(Sales ~ ., data = bluestem_1)
summary(add.fit.3)
```

########################################################
Try the open day time line (the lag effect also changes)
########################################################
```{r}
#Model add.fit.4 - Sales ~ time (open) + promo + dummy
bluestem_1 <- bluestem[,c(1:8,13)]
add.fit.4 <- lm(Sales ~ ., data = bluestem_1)
summary(add.fit.4)
#Model add.fit.5 - Sales ~ time (open) + promo (+lag1) + dummy
bluestem_1 <- bluestem[,c(1:8,13,16)]
add.fit.5 <- lm(Sales ~ ., data = bluestem_1)
summary(add.fit.5)
#Model add.fit.6 - Sales ~ time (open) + promo (+lag1&2) + dummy
bluestem_1 <- bluestem[,c(1:8,13,16,17)]
add.fit.6 <- lm(Sales ~ ., data = bluestem_1)
summary(add.fit.6)
```

add.fit.2 is better than other additive models
```{r}
check_assumption(add.fit.2)
```
Fail BP and CO test.

## Multiplicative Model
The nightly index expresses each Weekday??s effect on the popularity. 

#### 1. Use De-seasonalized Sales.

```{r}
#Model mtp.fit.1 - desSales ~ time (full) + promo
mtp.fit.1 <- lm(desSales ~ Promotion + timeindex, data = bluestem)
summary(mtp.fit.1)
# The coefficient of Promotion stands for the boost in revenues without Weekday effect. Such boost would be amplified by the Nightly Index for Saturday.
mtp.fit.1$coefficients[2] * index_table$Index[which(index_table$Weekday=="Saturday")]
```

```{r}
# Checking model assumptions
check_assumption(mtp.fit.1)
```

BP test and CO test don't pass

```{r}
#Model mtp.fit.2 - desSales ~ time (full) + promo + lag1
mtp.fit.2 <- lm(desSales ~ Promotion + timeindex + prolag1, data = bluestem)
summary(mtp.fit.2)
#Model mtp.fit.3 - desSales ~ time (full) + promo + lag1&2
mtp.fit.3 <- lm(desSales ~ Promotion + timeindex + prolag1 + prolag2, data = bluestem)
summary(mtp.fit.3)
```

fit.2 is better than fit.3, so we take fit.2 to run tests

```{r}
check_assumption(mtp.fit.2)
```
Same as before, both fail

CO Procedure
```{r}
co.test <- lm(formula = mtp.fit.2$residuals ~ Lag(mtp.fit.2$residuals, 1))
rho <- co.test$coefficients[2]
bluestem.CO.1 <- lapply(bluestem[,c(19,2,12,14)], as.numeric)
bluestem.CO.1 <- bluestem.CO.1[-1,]-bluestem.CO.1[-249,]*rho
co.fit.1 <- lm(desSales ~ Promotion + timeindex + prolag1, data = bluestem.CO.1)
summary(co.fit.1)
check_assumption(co.fit.1)
```
Autocorrelation problem solved, but still cannot pass BP-test.

#### 2. Try log(De-seasonalized Sales) to solve Heteroskedasticity problem

```{r}
bluestem$log_desSales <- log(bluestem$desSales)
mtp.fit.4 <- lm(log_desSales ~ Promotion+timeindex, data = bluestem)
summary(mtp.fit.4)
mtp.fit.5 <- lm(log_desSales ~ Promotion+timeindex+prolag1, data = bluestem)
summary(mtp.fit.5)
mtp.fit.6 <- lm(log_desSales ~ Promotion+timeindex+prolag1+prolag2, data = bluestem)
summary(mtp.fit.6)
# 
# # Checking model assumptions
# par(mfrow=c(2,2))
# plot(mtp.fit.2)
# mtp.fit.2$coefficients[2]
# # Promotion increases sales without Weekday effect by 52.284%. Now factor in the Saturday effect in terms of % increase:
# mtp.fit.2$coefficients[2] * ((index_table$Index[which(index_table$Weekday=="Saturday")] - 1)/1)
```
mtp.fit.6 is the best of the three log(Y) models in terms of adjusted R-square.

```{r}
# Checking model assumptions
check_assumption(mtp.fit.6)
```
Still not able to pass BP-test.

## Comparison

```{r}
## 3 models are selected in first round selection  add.fit.2 mtp.fit.2 and mtp.fit.6
## L1 L2 percentage---- these three criteria are used to evaluate them
Error <- matrix(0,nrow=3,ncol=3)
colnames(Error) <- c("Mean Squared Error","Absolute Error","Absolute Error Percentage")
rownames(Error) <- c("add.fit.2","mtp.fit.2","mtp.fit.6")
## add.fit.2
add.pd.2 <- predict(add.fit.2,bluestem)
dif <- bluestem$Sales-add.pd.2
Error[1,1] <- crossprod(dif,dif)/249
Error[1,2] <- sum(abs(dif))/249
Error[1,3] <- sum(abs(dif/bluestem$Sales))/249
## mtp.fit.2
mtp.pd.2 <- predict(mtp.fit.2,bluestem)*bluestem$Index
dif <- bluestem$Sales-mtp.pd.2
Error[2,1] <- crossprod(dif,dif)/249
Error[2,2] <- sum(abs(dif))/249
Error[2,3] <- sum(abs(dif/bluestem$Sales))/249
## mtp.fit.6
mtp.pd.6 <- exp(predict(mtp.fit.6,bluestem))*bluestem$Index
dif <- bluestem$Sales-mtp.pd.6
Error[3,1] <- crossprod(dif,dif)/249
Error[3,2] <- sum(abs(dif))/249
Error[3,3] <- sum(abs(dif/bluestem$Sales))/249
knitr::kable(Error,format = "markdown")
```



**Model assumptions:**  
The additive model is much better in terms of R-square and residual plots. The multiplicative model using log(De-seasonalized Sales) is better than the one directly using De-seasonalized Sales.  
**Business perspective:**   
The multiplicative model is better than the additive model. The additive model assumes that promotions have same boost effect on all weekdays, which is not the case. Promotional events should have better results with larger customer traffic. This is better addressed by the multiplicative model.